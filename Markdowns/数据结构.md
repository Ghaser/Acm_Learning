 注：寻找最优解！！！

# 线性表

## 	基础链表

### 			LeetCode 206 反转链表

​	思路：从头开始依次反转，记得记录下下一位的位置便可

```c++
class Solution {
	public:
    	ListNode* reverseList(ListNode* head) {
        	ListNode* prev = nullptr;
       		ListNode* curr = head;
        	while (curr) {
            	ListNode* next = curr->next;
            	curr->next = prev;
            	prev = curr;
            	curr = next;
        }
        	return prev;
    }
};
```



## 	单调栈

**定义**

单调递增栈：从栈底到栈顶的元素关键字的大小单调递增；

单调递减栈：从栈底到栈顶的元素关键字的大小单调递减；

## 	队列



# 串

## KMP算法

### 概念

**目标串**

- 当我们需要在字符串 T 中找子串 M 是否存在时，这里的 T 就是 **目标串**；

**匹配串**

- 当我们需要在字符串 T 中找子串 M 是否存在时，这里的 M 就是 **匹配串**；

**真前后缀**

- 一个串的真后缀就是不包含它本身的后缀；
- 一个串的真前缀就是不包含它本身的前缀；
- 定义既是真前缀又是真后缀的字符串为真前后缀



### KeyPoint：next数组

​		**next[k]的值为匹配字符串前k位最长前后缀的长度**

​		例如，对于字符串ababaca，长度为7，

```c++
void Getnext(int next[],string t){
    int j=0,k=-1;
    next[0]=-1;
    while(j<t.length-1){
        if(k==-1||t[j]==t[k]){
            j++;
            k++;
            if(t[j]=t[k]){
                next[j]=next[k];
            }else{
                next[j]=k;
            }
        }else k=next[k];//向前回溯，
    }
}
```

​		k=next[k]的本质是向前回溯

​		事实上，在向后遍历一位时，对于最大前后缀仅有三种结果，变为1，变为0，或者加1（证明显然）

​		所以我们将k=next[k]换成k--亦能满足回溯的需求

### KPM

KPM在存在重复片段的字符串中才能发挥其优越性（否则next全部为0）

```c++
//关键步骤： j=next[j];
//只考虑j！=0的情况（否则等价于普通情况）
//下给出实例
//a b c a b c a b g
//a b c a b g
//当i，j分别指向c，g时，执行j=next[j]；
//而易知next[5]=2
//故j重新指向2，完成接下来的判断
//故j=next[j]的实质是将j的位置转移到当前已读入字符串最大前后缀中前缀的后一位，例如abcab中ab的后一位c



int KMP(String s,String t)
{
   int next[MaxSize],i=0;j=0;
   Getnext(t,next);//获取next数组不同下标的值
   while(i<s.length&&j<t.length)
   {
      if(j==-1 || s[i]==t[j])
      {
         i++;
         j++;
      }
      else j=next[j]; //不同于求取next时的操作
   }
   if(j>=t.length)
       return (i-t.length);         
   else
      return (-1);               
}

```



# ”树“学

## 二叉树的遍历

​	前序遍历（基于string）

```c++
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

int n;
string s;
int main(){
    cin>>n;
    cin>>s;
    for(int i=2;i<=n;i++){
        string ss;
        cin>>ss;
        int x=s.find(ss[0]);
        s.erase(x,1);//x代表位置，1代表删除字符的长度
        s.insert(x,ss);//insert(num,s)往s的第x位插入s
    }
    for(int i=0;i<s.size();i++){
        if(s[i]!='*')cout<<s[i];
        else continue;
    }
    
    return 0;
}
```

## 字典树

### 基本概念

![](C:\Users\ROG\Desktop\P1.png)

1）**结点**：为了方便对结点进行索引，每个结点都用一个数字标识；

2）**根结点**：字典树的根结点只有一个，用数字 0 标识；

3）**树边**：字典树的树边上是对应字符串的字母；

4）**结尾结点**：结尾结点即图中的蓝色结点，用于标记一个完整字符串，即 **从根结点到蓝色结点路径上的字母** 所组成的字符串就是字符串集合中的字符串，这个例子中字符串集合有 7 个字符串，所以对应了 7 个蓝色结点。注意：**结尾结点并不一定是叶子结点。**

### 实现

#### 静态树类

```c++
const int TRIE_NODE_COUNT = 26;
const int TRIE_NODE_NULL = -1;

// 字典树结点类
class TrieNode {
private:
    bool isword_;   // 是否是1个完整字符串
    int num_;      // 有多少个单次经过这个结点
    int nodes_[TRIE_NODE_COUNT];  // 注意这里存的是结点内存池的下标，相比存指针的好处是：字节数少一半
public:
    inline void resetData(){
        num_ = 0;
        isword_ = false;
    }
    inline void reset() {
        resetData();
        memset(nodes_, TRIE_NODE_NULL, sizeof(nodes_));
    }
    // 接口部分暂时省略
    ...
};
```

需要通过哈希将字符集映射到下标处

#### 动态树类

```c++
const int TRIE_WORD_COUNT = 400000;
const int TRIE_WORD_LENGTH = 10;
const int TRIE_NODE_CACHES = TRIE_WORD_COUNT * TRIE_WORD_LENGTH;

// 字典
树类
class TrieTree {
public:
    TrieTree(int nodeCacheCount = TRIE_NODE_CACHES);
    virtual ~TrieTree();
    void initialize() {
        nodeId_ = 0;
        root_ = genNode();
    }
    // 接口部分暂时省略
    ...
private:
    int genNode() {
        TrieNode *pkNode = &(nodes_[nodeId_]);
        pkNode->reset();
        return nodeId_++;
    }
private:
    int nodeId_;
    int root_;
    TrieNode *nodes_;
};

TrieTree::TrieTree(int nodeCacheCount = TRIE_NODE_CACHES) : nodes_(NULL), 
                                                  root_(0), nodeId_(0) {
    nodes_ = new TrieNode[nodeCacheCount];
}
TrieTree::~TrieTree() {
    if (nodes_) {
        delete[] nodes_;
    }
}
```

#### 接口

a.字典树的插入

```c++
typedef const char ValueType;
void TrieTree::insert_word(int vSize, ValueType v[]) {   
    TrieNode *pkNow = root();
    for (int i = 0; i < vSize; ++i) {
        int nodeIdx = trieNodeValueHash(v[i]);
        //trieNodeValueHash将原数据类型转化为下标
        checkNode(pkNow, nodeIdx);            
        pkNow = node(pkNow->getNode(nodeIdx)); 
        pkNow->addNum(1);  
        //前缀标记自增1
    }
    pkNow->setWord(true);    
    //添加结尾标记
}

//checkNode用于检查当前结点是否存在nodeIdx这个子结点，不存在则创建1个
void TrieTree::checkNode(TrieNode *pkNow, int nodeIdx) {
    if (!pkNow->hasNode(nodeIdx)) {
        pkNow->setNode(nodeIdx, genNode());
    }
}

```

b.字典树的查询

```c++
bool TrieTree::query_word(int vSize, ValueType v[]) {
    TrieNode *pkNow = root();
    for (int i = 0; i < vSize; ++i) {
        int nodeIdx = trieNodeValueHash(v[i]);
        if (!hasNode(pkNow, nodeIdx)) {
            return false;
        }
        pkNow = node(pkNow->getNode(nodeIdx));
    }
    return pkNow->isWord();
}

```

### 应用

**1.前缀查询**

`【例题2】给定 n(n<=10^5)个长度不超过20的小写字母组成的字符串。再给出 m(m<=10^5)次询问，每次询问一个字符串 s，求出以s为前缀的字符串有多少个。`

**2.最短前缀表示**

`【例题3】给定 n(n<=1000) 个长度不超过 20 的小写字母组成的不同字符串，要求给出每个字符串的最短前缀表示，并且不产生冲突（当两个字符串拥有一个公共前缀 s 时就会产生冲突，s 不能作为两者的最短前缀表示）。`

利用字典序的_num即可

**3.删除字符串**

- 字符串的删除操作正好是插入操作的逆操作，还是遍历访问字符串，在访问到的结点将 `num_`值减 1 即可。如果能够将字符串都遍历完毕，则在最后一个结点将 `isword_`标记置成`false`。

**4.删除前缀**

**5.集合前缀**

**6.离线算法**

**7.模糊匹配**

**8.集合最大异或**

**9.树的异或最长路**

## 线段树

### 	数组实现

```c++
//关键函数
ll ls(ll p){return p<<1;}
ll rs(ll p){return p<<1|1;}
```

MAXNODE选定比n大的最小二次幂，再套用等比数列求和公式

### 	基本操作（Sum）

​		**构造**

```c++
void build(ll p,ll l,ll r){
    tag[p]=0;
    if(l==r){ans[p]=a[l];return;};//叶子节点，进行赋值
    ll mid=(l+r)>>1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
    up(p);//递归之后通过pushe函数来维护父子结点的关系
}



//
void up(ll p){//维护函数，建立父子节点间的联系
    ans[p]=ans[ls(p)]+ans[rs(p)];
    //针对求和的维护函数
}

void up(int p){//max and min
	 t[p]=min(t[lc(p)],t[rc(p)]);
     //t[p]=max(t[lc(p)],t[rc(p)]);    
    //针对区间最值的维护函数
}
```

​	**区间修改**

​	分块思想：将整个序列分成有穷个小块，对于要查询的一段区间，总是可以整合成k个所分块与m个单个元素的信息的并（可视为小区间）

​	**如果单个元素被包含就只改变自己，如果整个区间被包含就修改整个区间**

​	

​	Lazy-Tag原理：Lazy-Tag用以记录每次、每个结点要更新的值，而线段树的优点在于传递式记录。

​	**整个区间都被操作，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果四环以内只修改了自己的话，那就只改变自己。**

​	然而，采用上述优化方式时，我们需要在每次区间的查询修改时down

```c++
//适用于区间求和线段树的lazy-tag 
void updateOne(ll p,ll l,ll r,ll k){
    tag[p]=tag[p]+k;
    ans[p]=ans[p]+k*(r-l+1);
}

void lazy(ll p, ll l,ll r){
    ll mid=(l+r)>>1;
    updateOne(ls(p),l,mid,tag[p]);
    updateOne(rs(p),mid+1,r,tag[p]);
    tag[p]=0;
}
//

//常规的更新操作
void update(ll x,ll y,ll l,ll r,ll p,ll k)
{
    //----区间[x, y]完全覆盖[l, r]，则进行更新操作
    if(x<=l&&r<=y)
    {
        ans[p]+=k*(r-l+1);
        tag[p]+=k;
        return ;
    }
    
    lazy(p,l,r);
    
    
    ll mid=(l+r)>>1;
    if(x<=mid)update(x,y,l,mid,ls(p),k);
    if(y>mid) update(x,y,mid+1,r,rs(p),k);
    up(p);
}
```

​	**询问**

```c++
ll query(ll x,ll y,ll l,ll r,ll p){
    ll res=0;
    if(x<=l&&y>=r)return ans[p];
    ll mid=(l+r)>>1;
    lazy(p,l,r);
    if(x<=mid)res+=query(x,y,l,mid,ls(p));
    if(y>mid)res+=query(x,y,mid+1,r,rs(p));
    return res;
}
```

### 基本操作（Max）

**构造**

```c++
void build(ll p,ll l,ll r){
    if(l==r){ans[p]=w[l];return;};//叶子节点，进行赋值
    ll mid=(l+r)>>1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
    up(p);//递归之后通过pushe函数来维护父子结点的关系
}

void up(ll p){
    ans[p]=max(ans[ls(p)],ans[rs(p)]);
}//求最大值使用的max函数
```

**更新**

```c++
void update(ll p,ll l,ll r,ll x,ll k){
    if(l>x||r<x)return;//如果输入的x超出边界
    if(l==r){
        ans[p]=k;
        return;
    }//遍历到单个节点时
    int mid=(l+r)>>1;
    update(ls(p),l,mid,x,k);
    update(rs(p),mid+1,r,x,k);
    up(p);
    //魔改线段树，同时对num进行统计
}
```

**查询**

```c++
ll querymaxn(ll p,ll l,ll r,ll x,ll y){
    if(l>y||x>r)return 0;//范围越界
    if(l>=x&&y>=r)return ans[p];//完全覆盖
    ll mid=(l+r)>>1;
    return max(querymaxn(ls(p),l,mid,x,y),querymaxn(rs(p),mid+1,r,x,y));   
}//针对最大值的查询
```



### 经典实例及对应函数

#### 1.区间最值





## 树状数组

**概念**	

在储存空间上以数组的形式存储，即下标连续；其次，罪域两个数组下标x，y（x<y)，如果满足
$$
x+2^k=y(k等于x的二进制表示中末尾0的个数)
$$
则定义(y,x)为一组树上的父子关系，其中y为父节点，x为子节点。

​	![](E:\Tools\Typora Markdowns\da23a1adb9bd5ead455a8731e637dd1b.png)

**结点的含义**

​		节点C表示一段原数组A的区间和，右区间的下标为i，左区间的为顺着左儿子一直找到的叶子节点。

​		如i的二进制表示为（？？？？1000），则其最左边儿子结点的二进制表示显然为（？？？？0001），即左区间的下标是通过右区间下标减去2^k加上1得出。

​		固有


$$
C_i=\sum_{j=i-2^k+1}^iA_j
$$

### 实现

#### **求和操作**

递归求解，递归出口为i=0时，返回0.

```c++
int sum(int i) {
    return i ? C[i] + sum(i - lowbit(i)):0;
}
```

迭代求解

时间复杂度为O(logi)

```c++
int sum(int i) {
    int s = 0;
    while (i >= 1) {
        s += c[i];
        i -= lowbit(i);
    }
    return s;
}

```

#### 更新操作

​		需要在树状数组C上操作，而由求和公式知Ai的改变会影响Ci及其祖先结点，故有

```c++
const int maxn = 100000;

void add(int i, int v) {
    while (i <= maxn) {
        c[i] += v;
        i += lowbit(i);
    }
}

```

可以通过使用更新操作来构造树状数组

### 树状数组的经典模型

#### 1.单点更新，成段求和

#### 2.成段更新，单点求值

​	这类问题对树状数组稍微进行了一个转化，但是还是可以用add和sum 这两个函数来解决，对于操作 1 我们只需要执行两个操作，即add(x,v) 和add(y+1,−v)；而操作 2 则是输出sum(x) 的值。

### 应用场景

#### 	1.逆序对

​			时间复杂度
$$
O（log_n）
$$
​			实例：

```c++

```



#### 	2.K大数

​			

#### 	3.离散化

#### 	4.区间逆序对

#### 	5.树上逆序对

# HASH 

## 散列哈希（数的哈希）

### **1)哈希冲突**

**a.链地址法**

​		数组存储值数据的链表头，将所有取模后一样的哈希值用链表串起来，查找的时候先取模找到对应下标位置，然后在对应链表上遍历找到对应哈希值的数据。

**b. 开放寻址法**

​		数组存储值数据，如果遇到取模后发现已经有数据，则往数组后移一位，如果还有继续移动，直到找到一个空闲位置

### 2)负载因子

​			负载因子=哈希值个数/数组长度

​			对于链地址法来说，负载因子 > 5 就要考虑 rehash 了；而对于开放寻址法，负载因子 > 0.7 时，考虑 rehash

### 3)rehash

​		所谓 rehash，就是申请一块新的空间，空间的大小为原哈希数组的两倍，然后把原有的数据全部取出来映射到新的哈希数组里，再释放原有哈希数组。

​		实际实现的时候，为了减少申请空间带来的开销，一般是预先就一直有两个哈希数组（指针），然后采用滚动的方式进行扩容，扩容完毕交换指针。
​		并且由于一次 rehash 的耗时可能较长，一般采用渐进式 rehash，分散 CPU 的执行时间，具体细节可以参考 redis 源码的实现，这里不再展开来说了。

### 4)实现

```c++
#define HashValueType long long 
const int MAXH = (1 << 20);
bool hashkey[MAXH];                        // 1）
HashValueType hashval[MAXH];               

int getKey(HashValueType val) {
    int key = (val & (MAXH-1) );           // 2）
    while (1) {
        if (!hashkey[key]) {               // 3）
            hashkey[key] = true;
            hashval[key] = val;
            return key;
        }
        else {
            if (hashval[key] == val) {
                return key;               // 4）
            }
            key = (key + 1) & (MAXH - 1); // 5）
        }
    }
}

```

## 字符串哈希