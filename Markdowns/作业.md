```c++
#include<iostream>
using namespace std;
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;

void CreateList(LinkList &L,ElemType n);
//ADT中的创建链表，略
LinkList Listwork(LinkList &L,ElemType max,ElemType min){
    LNode p,q;
    q=L;
    p=L->next;
    while(p){
        if(p->data>min&&p->data<max){
           LNode temp=p;
           q->next=p->next;
           p=q->next;
           free(temp);
        }else if(p->data>=max){//已知数组为增序，故减少步骤
            break;
        }
    }
    return L;
}

int main(){
    ElemType max,min,n;
    cin>>min>>max>>n;//max,min的数据类型未知，迫不得已用cin
    CreateList(LinkList &L,ElemType n);
    Listwork(&L,max,min);
    
    return 0;
}
```

```c++
//只讨论L/2向下取整的情况
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
ll Merge(ll a[],ll b,ll n){
    ll s1=1,s2=1,e1=n,e2=n,m1,m2;
    while(s1!=e1||s2!=e2){//两序列等长，其实只要做一个就可以，但为了美观还是写两个吧
        m1=(s1+e1)>>1;//右移一位表示/2  位运算
        m2=(s2+e2)>>1;
        if(a[m1]<b[m2]){//情况1
            if((s1+e1)&1==1){//位运算判断剩余元素个数是否为偶数，使时间更加高效 注意：这里的奇偶非常容易弄错！！！！
                s1=m1+1;//a舍弃两个中间点的前一个点(/2点)及以前部分
                e2=m2;//b舍弃两个中间点的前一个点(/2点)及以后部分
            }else{//奇数！
                s1=m1;
                e2=m2;
            }
        }else if(a[m1]>b[m2]){
            if((s1+e1)&1==1){
                e1=m1;
                s2=m2+1;
            }else{
                e1=m1;
                s2=m2;
            }
        }else if(a[m1]==b[m2]{
            return a[m1];
        }
        
    }//这个是while的括号
       ll t=min(a[s1],b[s2]);//min存在algorithm头文件中
       return t;       
}


int main(){
    ios::sync_with_stdio(0);//加速cin和cout，优化时间
    ll n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        cin>>b[i];
    }
    cout<<Merge(a,b,n)<<endl;
    
    return 0;
}
```

```c++
#include<iostream>
#include<cstring>
#include<math>
using namespace std;
#define maxn 4294967295//2^32-1
bool judge[maxn];//不给数据范围只能开最大
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;

void CreateList(LinkList &L,ElemType n);
//ADT中的创建链表，略

LinkList Listwork(LinkList &L){
    LNode p=L;
    while(p){
        if(judge[abs(p->data)]){
            LNode temp=p;
            p=p->next;
            free(temp);
        }else{
            p=p->next;
            judge[abs(p->data)]=true;
        }
    }//while
    return L;
}

int main(){
    int n;
    cin>>n;
    memset(judge,false,sizeof(judge));
    CreateList(LinkList &L,ElemType n);
    Listwork(&L);
    return 0;
}
```

```c++
LinkList LocateNode(LinkList &L,int x){
    int judge=0;
    LNode p=L;
    while(p){
        if(p->data==x){
            p->freq++;
            LNode q=p->pred;
            while((q->freq<p->freq)&&(q->pred!=NULL)&&(p->pred!=NULL)){
                LNode temp1=p->next,temp2=q->pred;
                temp2->next=p;
                temp1->pred=q;
                q->next=p->next;
                p->pred=q->pred;
                p->next=q;
                q->pred=p;
                q=p->pred;//重新将q设置到p之前
            }
            p=p->next;
        }else{
            p=p->next;
        }
    }
    if(judge==0)return -1
    else return L;
}
```

```c++
#include<iostream>
using namespace std;
#define maxn 4294967295//2^32-1
int max(int x,int y){return x>y?x:y;}
int min(int x,int y){return x<y?x:y;}
int maxe=0,mine=maxn;//全局变量
void work1(int a[],int n){
    for(int i=1;i<=n;i++){
        mine=min(mine,a[i]);
        maxe=max(maxe,a[i]);
    }
}
void work2(int a[],int i){
    if(i==0){return;}
   	mine=min(mine,a[i]);
    maxe=max(maxe,a[i]);
    work(a[],i-1);
}
int main(){
    ios::sync_with_stdio(0);//加速cin和cout，优化时间
   	cin.tie(0);
    cout.tie(0);
    int n,a[maxn];
    cin>>n;
    for(int i=1;i<=n;i++){
		cin>>a[i];
  }
    work1(a,n);
    work2(a,n);
}
```

