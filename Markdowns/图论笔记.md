# 基础算法

### 链式前向星邻接表

以一组数据为例：

​    输入边的顺序如下：
​           1 2
​           2 3
​           3 4
​           1 3
​           4 1
​           1 5
​           4 5

  在链式前向星邻接表算法中我们可以得到以下结果：

​    （该部分只给出了有向图的例子，而图论中大部分是无向图，需进行双向处理）

   	 edge[0].to = 2; edge[0].next = -1; head[1] = 0;
   	    edge[1].to = 3; edge[1].next = -1; head[2] = 1;
   	    edge[2].to = 4; edge[2],next = -1; head[3] = 2;
   	    edge[3].to = 3; edge[3].next = 0; head[1] = 3;
   	    edge[4].to = 1; edge[4].next = -1; head[4] = 4;
   	    edge[5].to = 5; edge[5].next = 3; head[1] = 5;
   	    edge[6].to = 5; edge[6].next = 4; head[4] = 6;

​    我们不妨以起点1进行举例：

​           head[1] = 5 （以1为起点的第一条边的位置） -> edge[5].to = 5 （终点） ->        edge[5].next = 3（同一起点下一条边的位置） ->edge[3].to = 3（第二条边的终点）        -> edge[3].next = 0 -> edge[0].to = 2(第三条边的终点） ->edge[0].next = -1 （没     下一条边）

​    在这个过程中，我们成功的遍历与1相邻的三个顶点（5，3，2）

​	代码实现：

​	

```c++
struct edge{
    int next;//同一起点的上一条边的存储位置
    int to;//第i条边的重点
    int w;//第i条边的权重
}edge[maxn]
void add(int u,int v,int w){
    edge[++cnt].w=w;
    edge[cnt].to=v;
    edge[cnt].next=head[u];//只有当u与之前的u出现重复时，next的值才会发生改变
    head[u]=cnt;
}

```



# 最小生成树(MST)

### Prim算法

​		类似于最短路中的dijkstra算法。

​		在稠密图中优于kruskal算法

```c++
#include<bits/stdc++.h>
using namespace std;
int a,b,m[505][505],d[1005],vis[1005],ans=0;
int main(){
    ios::sync_with_stdio(false);//加速cin和cout
    cin>>a>>b;
    for(int i=1;i<=b;i++){
        for(int j=1;j<=b;j++){
            cin>>m[i][j];//读入原图各边的长短
            if(m[i][j]==0||m[i][j]>a){
                m[i][j]=a;
            }
        }
    }
    memset(d,0x7f,sizeof(d));//Prim算法中关键的距离函数
    for(int i=1;i<=b;i++){
        d[i]=m[1][i];//首先将距离函数设置为起始点到其余点的距离
    }
    d[1]=a;
    vis[1]=1;//记录下已经选取过的顶点
    for(int i=1;i<=b;i++){
        int k=0;
        for(int j=1;j<=b;j++){
            if(!vis[j]&&d[j]<d[k]){
                k=j;
            }
        }
        vis[k]=1;
        for(int j=1;j<=b;j++){
            if(!vis[j]&&m[k][j]<d[j]){
                d[j]=m[k][j];
            }
        }
    }
    for(int i=1;i<=b;i++){
        ans+=d[i];
    }
    cout<<ans;
 
}
```

### Kruskal算法

```c++
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005
struct Edge{
    int u,v,w;
}edge[maxn];
int fa[5005],n,m,ans,en,ev,cnt;

bool cmp(Edge a,Edge b){
    return a.w<b.w;
}

int find(int x){
    if(fa[x]==0){
        return x;
    }
    fa[x]=find(fa[x]);
    return fa[x];
}//关键并查集算法

void kruskal(){
    sort(edge,edge+m,cmp);
    for(int i=0;i<m;i++){
        eu=find(edge[i].u);
        ev=find(edge[i].v);
        if(eu==ev){
            continue;//该情况下说明u，v两点已然联通
        }
        fa[ev]=eu;//否则使这两点联通，并添加新边
        if(++cnt==n-1){
            break;
        }
    }
}

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        fa[i]=i;
    }
    for(int i=0;i<m;i++){
        cin>>edge[i].u>>edge[i].v>>edge[i].w;
    }
    kruskal();
    cout<<ans;
    return 0;
}
```

# 最短路

### Dijkstra算法（堆优化）

**注：在具有负权边的图中不可用**

堆优化的主要思想就是使用一个优先队列（就是每次弹出的元素一定是整个队列中最小的元素）来代替最近距离的查找，用邻接表代替邻接矩阵，这样可以大幅度节约时间开销。

在这里有几个细节需要处理：

·    首先来讲，优先队列的数据类型应该是怎样的呢？

我们知道优先队列应该用于快速寻找距离最近的点。由于优先队列只是将最小的那个元素排在前面，因此我们应该定义一种数据类型，使得它包含**该节点的编号**以及**该节点当前与起点的距离**。

·    我们应该在什么时候对队列进行操作呢？

队列操作的地方，首先就是搜索刚开始，要为起点赋初始值，此时必须将起点加入优先队列中。该队列元素的**节点编号**为**起点的编号**，**该节点当前与起点的距离**为00。

·    那么如果一个节点到起点的最短距离通过其他的运算流程发生了变化，那么如何处理队列中的那个已经存入的元素？

事实上，你不需要理会队列中的元素，而是再存入一个就行了。因为如果要发生变化，只能将节点与起点之间的距离变得更小，而优先队列恰好是先让最小的那个弹出。

**因此，轮到某一个队列元素弹出的时候，如果有多个元素的节点编号相同，那么被弹出的一定是节点编号最小的一个。等到后面再遇到这个节点编号的时候，我们只需要将它忽略掉就行了**。

```c++
#include<bits/stdc++.h>
using namespace std;
#define maxn 100010
int n,m,dis[maxn],head[maxn],cnt=0;
struct Edge{
    int v,w,nxt;
}e[5*maxn];
void addEdge(int u,int v,int w){
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=haed[u];
    head[u]=cnt;
}//链式前向星邻接表算法
struct node{
    int u,d;//u表示当前所在节点，而d表示已经走过的距离
    bool operator<(const node& rhs)const{//重载运算符
        return d>rhs.d;
    }
}
void Dijkstra(){
    for(int i=1;i<=n;i++)dis[i]=123456789;
    dis[s]=0;//起始点到自身的距离设置为0
    priority_queue<node> Q;
    Q.push((node){s,0});
    while(!Q.empty()){
        node fr=Q.top();
        Q.pop();
        int u=fr.u,d=dr.d;
        if(d!=dis[u])continue;
        for(int i=head[u];i;i=e[i].nxt){//遍历所有以u为起点的边
            int v=e[i].v,w=e[i].w;
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                Q.push((node){v,dis[v]});
            }
        }
    }
}
int main(){
    cin>>n>>m>>s;
    for(int i=1;i<=m;i++){
        cin>>X>>Y>>Z;
        addEdge(X,Y,Z);
    }
    Dijkstra();
    for(int i=1;i<=n;i++){
        cout<<dis[i];
    }
    return 0;
}
```



### Bellman-Ford算法

```c++
//进行n-1次松弛（更新）操作，可以得到最短路径，优点在于可以计算带有负权边的图
bool BellmanFordUpdate() {
    bool flag = false;
    for (int i = 0; i < edgeCount; ++i) {
        Edge &edge = edges[i];
        if (dist[edge.u] + edge.w < dist[edge.v]) {
            flag = true;
            dist[edge.v] = dist[edge.u] + edge.w;
        }
    }
    return flag;
}

bool BellmanFord(int n) {
    for (int i = 0; i < n; ++i) {
        dist[i] = (i==s)?0:inf;
    }            
    for (int i = 0; i < n - 1; ++i) {
        if (!BellmanFordUpdate()) {     
            return false;
        }
    }
    return BellmanFordUpdate();         
}

```



### SPFA算法

​      SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用**先进先出(FIFO)队列**进行优化的一个计算**单源最短路**的快速算法。
​      类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用**链式前向星**来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) < d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 
​      只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。
​      那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] > n，则表明这个图中存在负权圈。
​       接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。

```c++
//注意：本算法中所用链式前向星以-1为起始，故在for循环中以~e为终止条件
bool SPFA(int n, int st, ValueType *dist) {
    //------初始化--------
    queue <int> que;
    for (int i = 0; i < n; ++i) {
        dist[i] = (st == i) ? 0 : inf;
        inqueue[i] = (st == i);
        visited[i] = 0;
    }
    que.push(st);
    //------主要流程------
    while (!que.empty()) {
        int u = que.front();           
        que.pop();
        inqueue[u] = false;           
        if (visited[u] ++ > n) {      
            return true;
        }
        for (int e = head[u]; ~e; e =edges[e].next) {
        int v = edges[e].v;
        if (dist[u] + edges[e].w < dist[v]) {
            dist[v] = dist[u] + edges[e].w;
            if (!inqueue[v]) {
                inqueue[v] = true;
                que.push(v);
            }
        }
    }
    return false;
}

```

### Floyd—Warshall

- ​	Floyd算法基于动态规划的思想

- ​	d[k] [i] [j]表示只允许经过节点[0,k]的情况下，i到j的最短路，利用最优子结构性质，有两种情况：

- 1）最短路经过k点，则d[k] [i] [j]=d[k-1] [i] [k]+d[k-1] [k] [j]

- 2）最短路不经过k点，则 d[k] [i] [j] =d [k-1] [i] [j]

- 采用滚动数组优化为二维数组后，可得状态转移方程，时间复杂度为O(n^3)，空间复杂度为O(n^2)

  ```c++
  void FloydWarshall(int n) {
      int i, j, k;
      for (k = 0; k < n; ++k)
          for (i = 0; i < n; ++i)
              for (j = 0; j < n; ++j)
                  d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
  }
  ```

  ​	而判断是否连通的warshall算法代码实现如下

  ```c++
  void FloydWarshall(int n) {
      int i, j, k;
      for (k = 0; k < n; ++k)
          for (i = 0; i < n; ++i)
              for (j = 0; j < n; ++j)
                  d[i][j] = d[i][j] || (d[i][k] && d[k][j]);
  }
  ```

  

​	

# 拓扑排序

算法前提：有向无环图

### kahn算法

关键：维护一个入度为0的顶点的集合

```c++
queue<int> q;
vector<int> edge[n];//edge[i]为i对应的边集，储存量为另一端点
for(int i=0;i<n;i++){
    if(in[i]==0)q.push(i);//将入读为0的点入队列
}
vector<int>ans;//ans为拓扑序列
while(!q.empty()){
    int p=q.front();
    q.pop();
    ans.push_back(p);
    for(int i=0;i<edge[p].size();i++){
        int y=edge[p][i];
        in[y]--;//对应端点入度减一
        if(in[y]==0)
            q.push(y);
    }
}
if(ans.size()==n){
    for(int i=0;i<ans.size();i++){
        printf("%d",ans[i]);
    }
    printf("\n");
}else printf("NO Answer!\n");
```

### DFS算法

```c++

```

# 二分图的最大匹配 

### 匈牙利算法

算法核心：寻找增广路径

**匈牙利算法寻找最大匹配，就是通过不断寻找原有匹配M的增广路径，因为找到一条M匹配的增广路径，就意味着一个更大的匹配M' , 其恰好比M 多一条边。**

```c++
bool find(int x){
	int j;
    for(int j=1;j<=m;j++){
        if(line[x][j]==true&&used[j]==false){//注意，used数组只用于递归过程中保障不重复
            used[j]=1;
         	if(node[j]==0||find(node[j])){//node数组用于标记，保障整个匹配过程中不出现重复
                node[j]=x;
                return true;
            }
        }
    }
	return false;
}

for(int i=1;i<=n;i++){
    memset(used,0,sizeof(used));
    if(find(i)) all+=1;
}
```

#### example-POJ3041

​		**代码易实现，思想价更高**

​		将方阵看作特殊的二分图，行、列作为两个顶点集，每行每列都看成一个点，而若障碍物（x,y）则可看作连接x，y的边。故我们只需寻找最少的顶点（行列）使其覆盖所有的边（障碍物）即可，即求解最小点覆盖数。

​		**定理：最小点覆盖数等于最大匹配数**

​		所以我们考虑匈牙利算法

```c++
#include<iostream>
#include<cstring>
using namespace std;
int n,k;
int line[505][505],used[505],node[505],ans=0;

bool find(int x){
    for(int i=1;i<=n;i++){
        if(line[x][i]==1&&used[i]==0){
            used[i]=1;
            if(node[i]==0||find(node[i])){
                node[i]=x;
                return true;
            }
        }
    }
    return false;
}

int main(){
    ios::sync_with_stdio(0);
    cin>>n>>k;
    for(int i=1;i<=k;i++){
        int a,b;
        cin>>a>>b;
        line[a][b]=1;
    }
    for(int i=1;i<=n;i++){
        memset(used,0,sizeof(used));
        if(find(i))ans+=1;
    }
    cout<<ans;
    return 0;
}
```

#### 应用

1. 二分图最小顶点覆盖 = 二分图最大匹配
2. 二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配。
3. 二分图的最大独立集 = 顶点总数 - 最小顶点覆盖。
4. 有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数
5. 首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数。

# 最近公共祖先(LCA)

### 倍增算法

​	递推预处理出log(i)+1

```c++
for(int i=1;i<=n;i++){
    lg[i]=lg[i-1]+(1<<lg[i-1]==i);
}
```

​	记录各个点的深度以及其2^i级的祖先	

​		数组*depth* 存储每个节点的深度

​		数组*fa[i] [j]*  存储 节点i的2^j级祖先

```c++
void dfs(int now, int fath) {  //now表示当前节点，fath表示它的父亲节点
	fa[now][0] = fath; depth[now] = depth[fath] + 1;
	for(int i = 1; i <= lg[depth[now]]; ++i)
    	fa[now][i] = fa[fa[now][i-1]][i-1]; //这个转移可以说是算法的核心之一
	                                //意思是now的2^i祖先等于now的2^(i-1)祖先的2^(i-1)祖先
                                    	//2^i = 2^(i-1) + 2^(i-1)
	for(int i = head[now]; i; i = e[i].nex)
    	if(e[i].t != fath) dfs(e[i].t, now);
}
```

​	倍增LCA

​		先提高到同一高度，再一起向上跳

```c++
int LCA(int x, int y) {
	if(depth[x] < depth[y]) //用数学语言来说就是：不妨设x的深度 >= y的深度
		swap(x, y);
	while(depth[x] > depth[y])
		x = fa[x][lg[depth[x]-depth[y]] - 1]; //先跳到同一深度
	if(x == y)  //如果x是y的祖先，那他们的LCA肯定就是x了
		return x;
	for(int k = lg[depth[x]] - 1; k >= 0; --k) //不断向上跳（lg就是之前说的常数优化）
		if(fa[x][k] != fa[y][k])  //因为我们要跳到它们LCA的下面一层，所以它们肯定不相等，如果不相等就跳过去。
	    	x = fa[x][k], y = fa[y][k];
	return fa[x][0];  //返回父节点
}
```

