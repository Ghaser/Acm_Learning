# 搜索

### DFS

​		基本思想：一直往深处走，直到找到解或者走不下去

​		方法：递推

```c++
int DFS(int t)
{
    if(找到解或者越界（走不下去）或者满足条件)
    {
        Return；
	或者输出解
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                DFS(t+x[i]);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}

```



### BFS

​		基本思想：类似二叉树的层序遍历算法，从一个顶点开始，辐射状地优先遍历其周围较广的区域。

​    	实现的是一个分层的查找过程，所以不像DFS一样借助递归算法，而是借助一个辅助队列并且以非递归的形式来实现。

  		有关步骤：
  	
  	1、首先创建一个visit[ ]数组和一个队列q，分别用来判断该位置是否已经访问过及让未访问过的点入队；
  	2、初始化visit[ ]数组，清空q队列；
  	3、让起点start入队，并使该点的visit置1；
  	4、while（！q.empty()）{......}执行搜索操作，
  	 		a、取出队头元素后使队头元素出队，判断该元素是否为目标到达点；
  	 		b、如果是目标点，就返回结果（一般是最短时间、最短路径）；
  		  c、如果不是目标点，就继续访问与其相邻的位置点，将可走的相邻的位置点入队，并更新visit[ ]数组；

# 动态规划（DP）

### 背包DP

#### 01背包

对于每一件物品，我们都只有选择与不选择两种情况，只需求出选择与不选择中更优的情况便可。

二维无优化版本

```c++
//dp[i][j]中i代表物体的编号，而j代表质量（金钱、空间等等）
for(int i=1;i<=n;i++){
    for(int j=m;j>=0;j--){
        if(j>=w[i]){
            dp[i][j]=max(dp[i-1][j],dp[i-1][w[i]]+v[i]);
        }else{
            dp[i][j]=dp[i-1][j];
        }
    }
}
```

一维优化版本

```c++
for(int i=1;i<=n;i++){
    for(int c=m;c>=0;c--){
        if(c>w[i]){
            f[c]=max(f[c],f[c-w[i]]+v[i]);
        }
    }
}
```

#### 完全背包

完全背包与01背包的区别便是每个物品都有无限件

```c++
for(int i=1;i<=n;i++){
    for(int j=w[i];j<=m;j++){
        f[c]=max(f[c],f[c-w[i]]+v[i]);
        ans=max(f[c],ans);
    }
}
```

### 线性DP

最长单调上升序列

二分解法（非DP）

```c++
for(int i=2;i<=n;i++){
    if(dp[len]<a[i])dp[++len]=a[i];
    else{
        
    }
}
```



### 区间DP

### 状压DP

# 排序

### 归并排序

```c++
void merge(int l,int r){
    if(l==r)return 0;//仅剩一个元素时
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid,r);//不断递归以进行区间分割
    int i=l,j=mid+1,p=l;
    while(i<=mid&&j<=r){
        if(a[i]>a[j])temp[++p]=a[++i];
        else temp[++p]=a[++j];
    }
    while(i<=mid)temp[++p]=a[++i];
    while(j<=r)temp[++p]=a[++j];
    for(int i=l;i<=r;i++)a[i]=temp[i];
}
```

# 前缀和和差分

### 前缀和

#### 一维前缀和

​	可理解为数学上一维数列的前n项和

```c++
int sum[1]=a[1]
for(int i=2;i<=n;i++){
    sum[i]=sum[i-1]+a[i];
}    
```

#### 二维前缀和

```c++
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        cin>>a[i][j];
    }
}
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1];
    }
}
```

### 差分

#### 一维差分

对于一个数列A，他的差分数列B定义为：
    B[1] = A[1] ,B[i] = A[i] - A[i-1] ( 2<=i<=n)
  容易发现，“前缀和” 和 “差分” 是一对互逆运算，差分序列B的前缀和序列就是原序列A，前缀和序列S的差分序列也是原序列A。
  把序列A的区间 [l,r] 加上 d（即把 Al，Al+1……Ar 都加上 d），其差分序列 B 的变化为 Bl 加 d，Br+1 减 d，其余位置不变。

```c++
b[1]=a[1];
for(int i=2;i<=n;i++){
    b[i]=a[i]-a[i-1];
}
```

#### 二维差分

```c++
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        p[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];
    }
}
```

