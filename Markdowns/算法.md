# 搜索

### DFS

​		基本思想：一直往深处走，直到找到解或者走不下去

​		方法：递推

```c++
int DFS(int t)
{
    if(找到解或者越界（走不下去）或者满足条件)
    {
        Return；
	或者输出解
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                DFS(t+x[i]);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}

```



### BFS

​		基本思想：类似二叉树的层序遍历算法，从一个顶点开始，辐射状地优先遍历其周围较广的区域。

​    	实现的是一个分层的查找过程，所以不像DFS一样借助递归算法，而是借助一个辅助队列并且以非递归的形式来实现。

  		有关步骤：
  	
  	1、首先创建一个visit[ ]数组和一个队列q，分别用来判断该位置是否已经访问过及让未访问过的点入队；
  	2、初始化visit[ ]数组，清空q队列；
  	3、让起点start入队，并使该点的visit置1；
  	4、while（！q.empty()）{......}执行搜索操作，
  	 		a、取出队头元素后使队头元素出队，判断该元素是否为目标到达点；
  	 		b、如果是目标点，就返回结果（一般是最短时间、最短路径）；
  		  c、如果不是目标点，就继续访问与其相邻的位置点，将可走的相邻的位置点入队，并更新visit[ ]数组；

## 	记忆化搜索

本质为DFS实现+DP思想（动态规划）

### 框架

#### 1.合法性剪枝

​		保证传入参数的合法性（数组越界）

#### 2.偏序关系剪枝

​		即满足题目中的条件

#### 3.记忆化剪枝

​		通过对应的哈希数组判断这个状态是否存在过，如果计算过则直接返回，时间复杂度O（1）

#### 4.递归计算结果并返回

​		深度优先搜索常规递归过程

### 应用



#### 1）路径问题

**一维**

​	斐波那契数列

**二维**

给定一个 n × m ( n , m ≤ 8 ) 的格子，要求从左下角走到右上角，求方案数

#### 2）字符串匹配问题



# 动态规划（DP）

### 背包DP

#### 01背包

对于每一件物品，我们都只有选择与不选择两种情况，只需求出选择与不选择中更优的情况便可。

二维无优化版本

```c++
//dp[i][j]中i代表物体的编号，而j代表质量（金钱、空间等等）
for(int i=1;i<=n;i++){
    for(int j=m;j>=0;j--){
        if(j>=w[i]){
            dp[i][j]=max(dp[i-1][j],dp[i-1][w[i]]+v[i]);
        }else{
            dp[i][j]=dp[i-1][j];
        }
    }
}
```

一维优化版本

```c++
for(int i=1;i<=n;i++){
    for(int c=m;c>=0;c--){
        if(c>w[i]){
            f[c]=max(f[c],f[c-w[i]]+v[i]);
        }
    }
}
```

#### 完全背包

完全背包与01背包的区别便是每个物品都有无限件

```c++
for(int i=1;i<=n;i++){
    for(int j=w[i];j<=m;j++){
        f[c]=max(f[c],f[c-w[i]]+v[i]);
        ans=max(f[c],ans);
    }
}
```

#### 多重背包

区别在于每种物品最多只能选取x[i]键

​		状态转移方程
$$
dp[i][j]=max(dp[i-1][j-c[i]*k]+w[i]*k)
$$
​		对于每一件物体，归类为以下两种情况：

​	1.不妨：等价于k=0的情况

​	2.放k个：

​		枚举所有满足条件的k就是我们所求的 "前i种物品恰好放入容量为j的背包" 的最大价值了。

```c++
//二维完全背包
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        for(int k=0;k<=limit[i];k++){
            dp[i][j]=max(dp[i][j],dp[i-1][j-p*c[i]*p]);
        }
        
    }
}
//一维优化，观察出dp[i][j]实际上与i关系不大
for(int i=1;i<=n;i++){
    for(int j=m;j>=0;j--){
        for(int k=0;k<=limit[i]&&k*c[i]<=j;k++){
            dp[j]=max(dp[j],dp[j-p*c[i]]);
        }
        
    }
}
```



### RMQ

**RMQ (Range Minimum / Maximum Query)** 问题是指：对于长度为*n*的数列*A*，回答若干询问 ***(A,i,j)（1<=i,j<=n)***，返回数列 A中区间在***[i,j]***中的最小 (大) 值所在的下标。也就是说，RMQ问题是指求区间最值的问题。

思想：**动态规划**

#### ST算法

##### 算法思想

​	*f[i] [j]*表示区间***[j,j+2^i)***内最大值的下标

![](E:\Tools\Typora Markdowns\pictures\640.png)

由于区间***[j,j+2^i)***长度为2^i，如果i>0，那么它可以分解成两个长度为2^i-1的区间，即：
$$
[j,j+2^i)=[j,j+2^{i-1})+[j+2^{i-1},j+2^i)
$$
![](E:\Tools\Typora Markdowns\pictures\640 (1).png)

由图可知，父区间的最小值一定来自两个子区间中最小值的小者，对于数组A，我们提供一个函数RMQ_MinIndex,函数传入两个小标，返回的是A数组中值较小的那个数的下标

```c++
int RMQ_MinIndex(ValueType A[],int l,int r){
    return A[r]<A[l]? r : l;
}
```

**故有状态转移方程**

![image-20210406220521831](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20210406220521831.png)

##### 预处理

给出数组A，我们可以通过这个状态转移方程，进行双层循环预处理求出f[i] [j]的值

```C++
const int MAXM = 18;
const int MAXN = (1<<MAXM)+1;

void RMQ_Init(ValueType A[], int ALen, int(*f)[MAXN]) {
    for (int i = 0; i < MAXM; i++) {
        for (int j = 1; j + (1 << i) - 1 <= ALen; j++) {
            if (i == 0) {
                f[i][j] = j;
            }
            else {
                f[i][j] = RMQ_MinIndex(A, f[i-1][j], f[i-1][j + (1<<(i - 1))]);
            }
        }
    }
}
```

##### 询问

- f[i] [j]的计算只是做了预处理，询问时不能保证每个询问区间长度都是2的幂

- 区间长度大于1时，即给定区间[a,b] (1<=a<b<=n)，必定可以找到两个区间的并为[a,b]，并且区间X的左端点为a，又端点为b，且两个区间长度相等，都是2的幂

- 设区间长度为2^k，则X表示的区间为[a,a+2^k），Y表示的区间为（b-2^k,b]，则须有
  $$
  2^{k+1}>=(b-a+1)
  $$
  即
  $$
  k>=log(b-a+1)
$$
  **预处理求出所有的k**
  
```c++
  for (i = 1; i <= n; i++) {
      lg2K[i] = k - 1;
      if ((1 << k) == i) k++;
  }
```

**查询代码**

```c++
  int RMQ_Query(ValueType A[], int(*f)[MAXN], int a, int b) {
      if (a == b) {
          return a;
      }
      else if (a > b) { 
          a = a^b, b = a^b, a = a^b;   // 交换 a 和 b 的值
      }
      int k = lg2K[b - a + 1];
      return RMQ_MinIndex(A, f[k][a], f[k][b - (1 << k) + 1]);
  }
```



### 线性DP

#### 最长单调子序列

##### 贪心+二分算法

```c++
for(int i=2;i<=n;i++){
    if(dp[len]<a[i])dp[++len]=a[i];
    else{
        int p1=lower_bound(dp+1,dp+len+1,a[i])-dp;
        //这里是lower_bound的用法，减去数组开头来得到数组下标
        dp[p1]=a[i];
    }
}
```

##### 常用定理结论

**Dilworth定理**：

​	最长不上升子序列的最小划分个数等于最长上升子序列的长度

​	最长上升子序列的最少划分个数等于最长下降子序列的个数

#### 最长公共子序列

##### **状态转移方程（朴素算法）**

![image-20210408085418452](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20210408085418452.png)

##### **空间优化**

​	每次求解最长公共子序列时只有该行和上一行的状态，采用滚动数组对状态转移进行优化

​	实现代码：

```c++
int cur = 1, last = 0;
    for (int i = 1; i <= vsize; ++i) {
        for (int j = 1; j <= hsize; ++j) {
            if (v[i] == h[j])
                f[cur][j] = f[last][j - 1] + 1;
            else
                f[cur][j] = max(f[cur][j - 1], f[last][j]);
        }
        	swap(last, cur);
    }
return f[last][hsize];
```

##### **时间优化**

​	当且仅当提供的两个数组中有一个中不存在重复元素（重复元素极少时也可，若重复元素过多，会加大时间复杂度）

​	可用a数组对b数组进行离散化生成 *a‘*  数组，此时我们只需求*a’* 的最长上升子序列即可

##### **路径回溯**

​	计算f[i] [j]的值时，可以用另一个数组p[i] [j] 记录当前状态是从哪个转移过来的，计算完所有状态后从p[n] [m]迭代求出路径

​	

```c++
int pack(int x, int y) {                              // pack函数将两个整数转化为一个唯一整数，注意这种转化方法
    return x * maxn + y;                             
}

int getLCSLength(int hsize, ValueType *h, int vsize, ValueType *v, stack<int>& path) {
    memset(f, 0, sizeof(f));
    while (!path.empty())                             // 使用栈来记录路径
        path.pop();
    int cur = 1, last = 0;
    for (int i = 1; i <= vsize; ++i) {
        for (int j = 1; j <= hsize; ++j) {
            if (v[i] == h[j]) {
                f[cur][j] = f[last][j - 1] + 1;
                p[i][j] = pack(i - 1, j - 1);         // 3）
            }
            else {
                f[cur][j] = max(f[last][j], f[cur][j - 1]);
                p[i][j] = f[last][j] > f[cur][j - 1] ? pack(i - 1, j) : pack(i, j - 1);
            }
        }
        swap(last, cur);
    }
    int vidx = vsize, hidx = hsize;
    while (vidx && hidx) {                        
        int pre = p[vidx][hidx];
        int previdx = pre / maxn;
        int prehidx = pre % maxn;
        if (vidx - previdx && prehidx - hidx) {      // 4）
            path.push(vidx * maxn + hidx);
        }
        vidx = previdx;
        hidx = prehidx;
    }
    return f[last][hsize];
}

```

##### **例题分析**

**最长单调公共子序列**

​	f[i] [j]表示恰好以bj作为最后一个元素的最长公共递增子序列的长度

​	

### 区间DP

模板

```c++
for(int len = 1;len<=n;len++){//枚举长度
        for(int j = 1;j+len<=n+1;j++){//枚举起点，ends<=n
            int ends = j+len - 1;
            for(int i = j;i<ends;i++){//枚举分割点，更新小区间最优解
                dp[j][ends] = min(dp[j][ends],dp[j][i]+dp[i+1][ends]+something);
            }
        }
    }
```



### 状压DP

#### 常用位运算

- **if(( (1<<(i-1) ) &x )>0 )   ** 判断一个数二进制下第i位是否等于1
- **x=x|(1<<(i-1))**                  将一个数二进制下第i位更改为1
- **x=x&(x-1)**                          去掉x二进制下最靠右的1
- 使用位运算 对状态进行修改

#### **状态转移函数**

​	dp[i] [state] [……]  用state来表示i-1行对第i行影响的结果

​	状态压缩动态规划最重要的是考虑前一阶段对后一阶段状态的影响

### 数位DP



# 排序

### 归并排序

```c++
void merge(int l,int r){
    if(l==r)return 0;//仅剩一个元素时
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid,r);//不断递归以进行区间分割
    int i=l,j=mid+1,p=l;
    while(i<=mid&&j<=r){
        if(a[i]>a[j])temp[++p]=a[++i];
        else temp[++p]=a[++j];
    }
    while(i<=mid)temp[++p]=a[++i];
    while(j<=r)temp[++p]=a[++j];
    for(int i=l;i<=r;i++)a[i]=temp[i];
}
```

# 前缀和和差分

### 前缀和

#### 一维前缀和

​	可理解为数学上一维数列的前n项和

```c++
int sum[1]=a[1]
for(int i=2;i<=n;i++){
    sum[i]=sum[i-1]+a[i];
}    
```

#### 二维前缀和

```c++
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        cin>>a[i][j];
    }
}
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1];
    }
}
```

### 差分

#### 一维差分

对于一个数列A，他的差分数列B定义为：
    B[1] = A[1] ,B[i] = A[i] - A[i-1] ( 2<=i<=n)
  容易发现，“前缀和” 和 “差分” 是一对互逆运算，差分序列B的前缀和序列就是原序列A，前缀和序列S的差分序列也是原序列A。
  把序列A的区间 [l,r] 加上 d（即把 Al，Al+1……Ar 都加上 d），其差分序列 B 的变化为 Bl 加 d，Br+1 减 d，其余位置不变。

```c++
b[1]=a[1];
for(int i=2;i<=n;i++){
    b[i]=a[i]-a[i-1];
}
```

#### 二维差分

```c++
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        p[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];
    }
}
```

